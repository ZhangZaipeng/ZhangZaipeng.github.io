优化步骤：
    1.网络优化：

    2.操作系统优化：内核参数优化、ulimit 优化

    3.tomcat 优化
        连接协议：非阻塞NIO
        连接数:maxConnections
        处理线程：maxThreads
        等候队列：acceptCount
        tomcat 内部线程数达到500 需要考虑做集群

    4.nginx 优化
        gzip压缩、超时时间
        动静分离
        负载均衡
    5.jvm参数优化：
        常规优化：
            1、禁用System.gc -XX:-DisableExplicitGC
            2、逃逸分析与标题替换 默认是启用的 -XX:+DoEscapeAnalysis
            3、关闭偏向锁优化
            4、指针压缩 -XX:+UseCompressedOops
            5、getter方法优化 -XX:UseFastAccessorMethods
        JIT优化：
            1、开启服务端模式 -server
            2、增加内联函数的可能性
            3、提高编译的可能性 -XX:CompileThreshold=10000
            4、降低线程优先级
            5、热度衰减与半衰周期
        内存优化：
            1、将新对象预留在年轻代，-XX:TargetSurvivorRatio=90
            2、让大对象进入年老代，-XX:PetenureSizeThreshold=1000000，1M
            3、设置对象进入年老代的年龄，-XX:MaxTenuringThreshold=31
            4、稳定的 Java 堆 ，Xmx与Xms相同
            5 、 增 大 吞 吐 量 提 升 系 统 性 能 ， –XX:+UseParallelGC ，
                –XX:+UseParallelOldGC，–XX:ParallelGC-Threads（CPU核心数相等）
            6、使用非占有的垃圾回收器，–XX:+UseConcMarkSweepGC
        经验值：
            java -Xmx3550m -Xms3550m -Xss128k -XX:NewRatio=4 -XX:SurvivorRatio=4 -XX:MaxPermSize=16m -XX:MaxTenuringThreshold=0
            调优方案：
            -Xmx5g：设置JVM最大可用内存为5G。
            -Xms5g：设置JVM初始内存为5G。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。
            -Xmn2g：设置年轻代大小为2G。
                整个堆内存大小 = 年轻代大小 + 年老代大小 + 持久代大小 。
                持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。
                此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。
            -XX:+UseParNewGC：设置年轻代为并行收集。
                可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。
            -XX:ParallelGCThreads=8：配置并行收集器的线程数，
                即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。
            -XX:SurvivorRatio=6：设置年轻代中Eden区与Survivor区的大小比值。
                根据经验设置为6，则两个Survivor区与一个Eden区的比值为2:6，一个Survivor区占整个年轻代的1/8。
            -XX:MaxTenuringThreshold=30： 设置垃圾最大年龄（次数）。
                如果设置为0的话，则年轻代对象不经过Survivor区直接进入年老代。
                对于年老代比较多的应用，可以提高效率。如果将此值 设置为一个较大值，则年轻代对象会在Survivor区进行多次复制，
                这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概率。
                设置为30表示 一个对象如果在Survivor空间移动30次还没有被回收就放入年老代。
            -XX:+UseConcMarkSweepGC：设置年老代为并发收集。
                测试配置这个参数以后，参数-XX:NewRatio=4就失效了，所以，此时年轻代大小最好用-Xmn设置，因此这个参数不建议使用


1.查看TCP 连接数
    netstat -n | awk '/^tcp/{++S[$NF]} END {for(a in S) print a, S[a]}'

    返回结果一般如下：
    LAST_ACK 5 （正在等待处理的请求数）
    SYN_RECV 30
    ESTABLISHED 1597 （正常数据传输状态）
    FIN_WAIT1 51
    FIN_WAIT2 504
    TIME_WAIT 1057 （处理完毕，等待超时结束的请求数）

    其他参数：
    CLOSED：无连接是活动的或正在进行
    LISTEN：服务器在等待进入呼叫
    SYN_RECV：一个连接请求已经到达，等待确认
    SYN_SENT：应用已经开始，打开一个连接
    ESTABLISHED：正常数据传输状态
    FIN_WAIT1：应用说它已经完成
    FIN_WAIT2：另一边已同意释放
    ITMED_WAIT：等待所有分组死掉
    CLOSING：两边同时尝试关闭
    TIME_WAIT：另一边已初始化一个释放
    LAST_ACK：等待所有分组死掉

2.查看java 进程的线程数
    ps -eLf | grep java |grep api| wc -l
    注意: Linux服务器每进程不允许超过1000个线程

2.网络参数 及 内核参数
    1.文件句柄（同时打开文件数，默认只有1024）查看
        ulimit -n 打开最大文件
        ulimit -s 线程栈大小
        ulimit -u 最大可用的进程数
    2.及时修改

    3.网络参数优化
        net.ipv4.tcp_syncookies = 1 开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少
        量SYN攻击；
        net.ipv4.tcp_tw_reuse = 1 开启重用。允许将TIME-WAIT sockets重新用于新的TCP连接，默认为0
        net.ipv4.tcp_tw_recycle = 1 开启TCP连接中TIME-WAIT sockets的快速回收，默认为0，表示关闭。
        net.ipv4.tcp_fin_timeout = 30 如果套接字由本端要求关闭，它决定了它保持在FIN-WAIT-2状态的时间。
        net.ipv4.tcp_keepalive_time = 1200 当keepalive起用的时候，TCP发送keepalive消息的频度。缺省是2小时
        net.ipv4.tcp_keepalive_intvl = 30
        net.ipv4.tcp_keepalive_probes = 3 probe 3次(每次30秒)不成功,内核才彻底放弃。
        tcp_keepalive_time = 7200 seconds (2 hours)
        tcp_keepalive_probes = 9
        tcp_keepalive_intvl = 75 seconds
        net.ipv4.ip_local_port_range = 1024 65000 用于向外连接的端口范围。缺省情况下很小：32768到61000，
        改为1024到65000。
        net.ipv4.tcp_max_syn_backlog = 8192 SYN队列的长度，默认为1024，加大队列长度为8192，可以容纳更多
        等待连接的网络连接数。
        net.ipv4.netdev_max_backlog = 1000 表示进入包的最大设备队列，默认300，改大
        net.core.tcp_max_tw_buckets = 5000 系统同时保持TIME_WAIT套接字的最大数量，如果超过这个数字，
        TIME_WAIT套接字将立刻被清除并打印警告信息。默认为180000，改为 5000。
        另外可以参考优化内核配置：
        /proc/sys/net/core/wmem_max 最大socket写buffer,可参考的优化值:873200
        /proc/sys/net/core/rmem_max 最大socket读buffer,可参考的优化值:873200
        /proc/sys/net/ipv4/tcp_wmem TCP写buffer,可参考的优化值: 8192 436600 873200
        /proc/sys/net/ipv4/tcp_rmem TCP读buffer,可参考的优化值: 32768 436600 873200
        /proc/sys/net/ipv4/tcp_mem
        同样有3个值,意思是:配置单位为页，不是字节
        net.ipv4.tcp_mem[0]:低于此值,TCP没有内存压力. 786432
        net.ipv4.tcp_mem[1]:在此值下,进入内存压力阶段. 1048576
        net.ipv4.tcp_mem[2]:高于此值,TCP拒绝分配socket. 1572864
        /proc/sys/net/core/somaxconn 256
        listen()的默认参数,挂起请求的最大数量.默认是128.对繁忙的服务器,增加该值有助于网络性能.
        /proc/sys/net/core/optmem_max socket buffer的最大初始化值,默认10K.
        /proc/sys/net/ipv4/tcp_retries2 TCP失败重传次数,默认值15.减少到5,以尽早释放内核资源.
        net.core.somaxconn = 32768 socket监听（listen）的backlog上限，是socket的监听队列。比如nginx 定义
        NGX_LISTEN_BACKLOG默认到511


3.tomcat参数优化



