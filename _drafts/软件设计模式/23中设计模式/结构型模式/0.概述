1.结构型模式概述
  结构型模式描述如何将类或对象按某种布局组成更大的结构。
  它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者釆用组合或聚合来组合对象。


2.结构型模式分为以下 7 种：
  代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
  适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
  桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。
  装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。
  外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
  享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
  组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。

3.代理模式
  1.定义
    由于某些原因需要给某对象提供一个代理以控制对该对象的访问。
    这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。
  2.模式的结构
  代理模式的主要角色如下。
    1.抽象主题（Subject）类：通过接口或抽象类声明真实主题和代理对象实现的业务方法。
    2.真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象。
    3.代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能。
  3.实现 ： 代码

4.适配器模式
  1.定义
    将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作
  2.模式的结构
    适配器模式（Adapter）包含以下主要角色。
      目标（Target）接口：当前系统业务所期待的接口，它可以是抽象类或接口。
      适配者（Adaptee）类：它是被访问和适配的现存组件库中的组件接口。
      适配器（Adapter）类：它是一个转换器，通过继承或引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者。

5.桥接模式
  1.桥接模式定义
    将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。
  2.模式的结构
    1.抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。
    2.扩展抽象化（Refined    Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。
    3.实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。
    4.具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。
6.装饰模式
  1.装饰模式定义
    指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。
  2.装饰模式模式的结构
    抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。
    具体构件（Concrete    Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。
    抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。
    具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。
7.外观模式
  1.外观模式定义
    是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。
    该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。
  2.外观模式的结构
    1.外观（Facade）角色：为多个子系统对外提供一个共同的接口。
    2.子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。
    3.客户（Client）角色：通过一个外观角色访问各个子系统的功能。

8.享元模式
  1.享元（Flyweight）模式的定义：
    运用共享技术来有効地支持大量细粒度对象的复用。
    它通过共享已经存在的又橡来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。
  2.模式的结构
    抽象享元角色（Flyweight）:是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。
    具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口。
    非享元（Unsharable Flyweight)角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。
    享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。
      当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。

9.组合模式
  1.组合（Composite）模式的定义：
    有时又叫作部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。
  2.模式的结构
    1.抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。
      在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。
    2.树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。
    3.树枝构件（Composite）角色：是组合中的分支节点对象，它有子节点。
      它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。
